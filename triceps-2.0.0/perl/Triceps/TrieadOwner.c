/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of TrieadOwner.xs. Do not edit this file, edit TrieadOwner.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "TrieadOwner.xs"
//
// (C) Copyright 2011-2014 Sergey A. Babkin.
// This file is a part of Triceps.
// See the file COPYRIGHT for the copyright notice and license information
//
// The wrapper for TrieadOwner.

#include <algorithm>

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include "TricepsPerl.h"
#include "TricepsOpt.h"
#include "PerlCallback.h"
#include "PerlApp.h"
#include "PerlTrieadJoin.h"
#include "TrackedFile.h"
#include <app/TrieadOwner.h>

#line 34 "TrieadOwner.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 176 "TrieadOwner.c"

XS_EUPXS(XS_Triceps__TrieadOwner_CLONE_SKIP); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_CLONE_SKIP)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 30 "TrieadOwner.xs"
		RETVAL = 1;
#line 188 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::DESTROY(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::DESTROY(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 37 "TrieadOwner.xs"
		// TrieadOwner *to = self->get();
		// warn("TrieadOwner %s %p wrap %p destroyed!", to->get()->getName().c_str(), to, self);
		delete self;
#line 217 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_new)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "CLASS, tid, handle, app, tname, fragname");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	WrapTrieadOwner *	RETVAL;
	SV *	tid = ST(1)
;
	SV *	handle = ST(2)
;
	SV *	app = ST(3)
;
	char *	tname = (char *)SvPV_nolen(ST(4))
;
	char *	fragname = (char *)SvPV_nolen(ST(5))
;
#line 54 "TrieadOwner.xs"
		static char funcName[] =  "Triceps::TrieadOwner::new";
		clearErrMsg();

		bool testfail = false;
		if (SvOK(tid) // check only if not undef
		&& !SvIOK(tid)) {
			// a special hidden case to test the failure handling
			if (SvPOK(tid) && !strcmp(SvPV_nolen(tid), "__test_fail__"))
				testfail = true;
			else
				croak("%s: tid argument must be either an int or an undef", funcName);
		}

		RETVAL = NULL; // shut up the compiler
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			string tn(tname);
			Autoref<TrieadOwner> to = appv->makeTriead(tn, fragname);
			PerlTrieadJoin *tj = new PerlTrieadJoin(appv->getName(), tname, 
				SvIOK(tid)? SvIV(tid): -1, 
				SvIOK(handle)? SvIV(handle): 0, 
				testfail);
			to->fileInterrupt_ = tj->fileInterrupt();
			appv->defineJoin(tn, tj);
			RETVAL = new WrapTrieadOwner(to);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 271 "TrieadOwner.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_app); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_app)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapApp *	RETVAL;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::app(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::app(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 87 "TrieadOwner.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::App";

		clearErrMsg();
		TrieadOwner *to = self->get();

		RETVAL = new WrapApp(to->app());
#line 306 "TrieadOwner.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_unit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_unit)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapUnit *	RETVAL;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::unit(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::unit(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 100 "TrieadOwner.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::Unit";

		clearErrMsg();
		TrieadOwner *to = self->get();

		RETVAL = new WrapUnit(to->unit());
#line 341 "TrieadOwner.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_markConstructed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_markConstructed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::markConstructed(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::markConstructed(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 113 "TrieadOwner.xs"
		clearErrMsg();
		TrieadOwner *to = self->get();
		try { do {
			to->markConstructed();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 373 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_markReady); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_markReady)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::markReady(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::markReady(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 122 "TrieadOwner.xs"
		clearErrMsg();
		TrieadOwner *to = self->get();
		try { do {
			to->markReady();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 403 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_readyReady); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_readyReady)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::readyReady(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::readyReady(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 131 "TrieadOwner.xs"
		clearErrMsg();
		TrieadOwner *to = self->get();
		try { do {
			to->readyReady();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 433 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_markDead); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_markDead)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::markDead(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::markDead(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 140 "TrieadOwner.xs"
		clearErrMsg();
		TrieadOwner *to = self->get();
		try { do {
			to->markDead();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 463 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_abort); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_abort)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, msg");
    {
	WrapTrieadOwner *	self;
	char *	msg = (char *)SvPV_nolen(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::abort(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::abort(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 149 "TrieadOwner.xs"
		clearErrMsg();
		TrieadOwner *to = self->get();
		try { do {
			to->abort(msg);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 495 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_get)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTriead *	RETVAL;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::get(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::get(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 158 "TrieadOwner.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::Triead";

		clearErrMsg();
		TrieadOwner *to = self->get();

		WrapTriead *wa = new WrapTriead(to->get());
		RETVAL = wa;
#line 529 "TrieadOwner.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_isRqDead); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_isRqDead)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::isRqDead(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::isRqDead(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 172 "TrieadOwner.xs"
		clearErrMsg();
		RETVAL = self->get()->isRqDead();
#line 560 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_getName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_getName)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	char *	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::getName(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::getName(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 182 "TrieadOwner.xs"
		clearErrMsg();
		Triead *t = self->get()->get();
		RETVAL = (char *)t->getName().c_str();
#line 591 "TrieadOwner.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_fragment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_fragment)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	char *	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::fragment(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::fragment(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 191 "TrieadOwner.xs"
		clearErrMsg();
		Triead *t = self->get()->get();
		RETVAL = (char *)t->fragment().c_str();
#line 622 "TrieadOwner.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_isConstructed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_isConstructed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::isConstructed(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::isConstructed(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 200 "TrieadOwner.xs"
		clearErrMsg();
		Triead *t = self->get()->get();
		RETVAL = t->isConstructed();
#line 653 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_isReady); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_isReady)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::isReady(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::isReady(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 209 "TrieadOwner.xs"
		clearErrMsg();
		Triead *t = self->get()->get();
		RETVAL = t->isReady();
#line 684 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_isDead); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_isDead)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::isDead(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::isDead(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 218 "TrieadOwner.xs"
		clearErrMsg();
		Triead *t = self->get()->get();
		RETVAL = t->isDead();
#line 715 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_isInputOnly); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_isInputOnly)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::isInputOnly(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::isInputOnly(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 227 "TrieadOwner.xs"
		clearErrMsg();
		Triead *t = self->get()->get();
		RETVAL = t->isInputOnly();
#line 746 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_makeNexus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_makeNexus)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	WrapFacet *	RETVAL;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::makeNexus(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::makeNexus(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 304 "TrieadOwner.xs"
		static char funcName[] =  "Triceps::TrieadOwner::makeNexus";
		static char CLASS[] = "Triceps::Facet";
		bool do_import = false; // whether to reimport the nexus after exporting it
		clearErrMsg();
		TrieadOwner *to = self->get();
		RETVAL = NULL;
		try { do {
			int len, i;
			// Unit *u = NULL;
			AV *labels = NULL;
			AV *rowTypes = NULL;
			AV *tableTypes = NULL;
			string name;
			bool reverse = false;
			bool chainFront = true;
			int qlimit = -1; // "default"
			string import; // the import type
			bool writer;

			if (items % 2 != 1)
				throw Exception::f("Usage: %s(self, optionName, optionValue, ...), option names and values must go in pairs", funcName);

			for (int i = 1; i < items; i += 2) {
				const char *optname = (const char *)SvPV_nolen(ST(i));
				SV *arg = ST(i+1);
				if (!strcmp(optname, "name")) {
					GetSvString(name, arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "labels")) {
					labels = GetSvArray(arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "rowTypes")) {
					rowTypes = GetSvArray(arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "tableTypes")) {
					tableTypes = GetSvArray(arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "reverse")) {
					reverse = SvTRUE(arg);
				} else if (!strcmp(optname, "chainFront")) {
					chainFront = SvTRUE(arg);
				} else if (!strcmp(optname, "queueLimit")) {
					qlimit = GetSvInt(arg, "%s: option '%s'", funcName, optname);
					if (qlimit <= 0)
						throw Exception::f("%s: option '%s' must be >0, got %d", funcName, optname, qlimit);
				} else if (!strcmp(optname, "import")) {
					GetSvString(import, arg, "%s: option '%s'", funcName, optname);
				} else {
					throw Exception::f("%s: unknown option '%s'", funcName, optname);
				}
			}

			Unit *u = to->unit();
			if (labels != NULL && av_len(labels) != -1)
				checkLabelList(funcName, "labels", u, labels);

			if (name.empty())
				throw Exception::f("%s: must specify a non-empty name with option 'name'", funcName);

			std::transform(import.begin(), import.end(), import.begin(), ::tolower);
			if (import.compare(0, 5, "write") == 0) {
				writer = true; do_import = true;
			} else if (import.compare(0, 4, "read") == 0) {
				writer = false; do_import = true;
			} else if (import.compare(0, 2, "no") == 0) {
				writer = false; do_import = false;
			} else {
				throw Exception::f("%s: the option 'import' must have the value one of 'writer', 'reader', 'no'; got '%s'", funcName, import.c_str());
			}

			// start by building the FnReturn
			Autoref<FnReturn> fret = new FnReturn(u, name);

			if (labels != NULL)
				addFnReturnLabels(funcName, "labels", u, labels, chainFront, fret);

			// now make the Facet out it
			Autoref<Facet> fa = new Facet(fret, writer);
			fa->setReverse(reverse);
			if (qlimit > 0)
				fa->setQueueLimit(qlimit);

			if (rowTypes) {
				len = av_len(rowTypes)+1; // av_len returns the index of last element
				for (i = 0; i < len; i+=2) {
					SV *svname, *svval;
					svname = *av_fetch(rowTypes, i, 0);
					svval = *av_fetch(rowTypes, i+1, 0);

					string elname;
					GetSvString(elname, svname, "%s: option 'rowTypes' element %d name", funcName, i+1);

					RowType *rt = TRICEPS_GET_WRAP(RowType, svval, 
						"%s: in option 'rowTypes' element %d with name '%s'", funcName, i/2+1, SvPV_nolen(svname)
					)->get();

					fa->exportRowType(elname, rt);
				}
			}

			if (tableTypes) {
				len = av_len(tableTypes)+1; // av_len returns the index of last element
				for (i = 0; i < len; i+=2) {
					SV *svname, *svval;
					svname = *av_fetch(tableTypes, i, 0);
					svval = *av_fetch(tableTypes, i+1, 0);

					string elname;
					GetSvString(elname, svname, "%s: option 'tableTypes' element %d name", funcName, i+1);

					TableType *tt = TRICEPS_GET_WRAP(TableType, svval, 
						"%s: in option 'tableTypes' element %d with name '%s'", funcName, i/2+1, SvPV_nolen(svname)
					)->get();

					fa->exportTableType(elname, tt);
				}
			}

			try {
				to->exportNexus(fa, do_import); // this checks the facet for errors
			} catch (Exception e) {
				throw Exception(e, strprintf("%s: invalid arguments:", funcName));
			}

			if (do_import)
				RETVAL = new WrapFacet(fa);
		} while(0); } TRICEPS_CATCH_CROAK;

		if (!do_import)
			XSRETURN_UNDEF; // NOT an error, just nothing to return
#line 899 "TrieadOwner.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_importNexus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_importNexus)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	WrapFacet *	RETVAL;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::importNexus(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::importNexus(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 497 "TrieadOwner.xs"
		static char funcName[] =  "Triceps::TrieadOwner::importNexus";
		static char CLASS[] = "Triceps::Facet";
		clearErrMsg();
		TrieadOwner *to = self->get();
		RETVAL = NULL;
		try { do {
			int len, i;
			// Unit *u = NULL;
			AV *labels = NULL;
			AV *rowTypes = NULL;
			AV *tableTypes = NULL;
			string from;
			string fromTriead;
			string fromNexus;
			string as;
			string import; // the import type
			bool immed = false;
			bool writer;

			if (items % 2 != 1)
				throw Exception::f("Usage: %s(self, optionName, optionValue, ...), option names and values must go in pairs", funcName);

			for (int i = 1; i < items; i += 2) {
				const char *optname = (const char *)SvPV_nolen(ST(i));
				SV *arg = ST(i+1);
				if (!strcmp(optname, "from")) {
					GetSvString(from, arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "fromTriead")) {
					GetSvString(fromTriead, arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "fromNexus")) {
					GetSvString(fromNexus, arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "as")) {
					GetSvString(as, arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "import")) {
					GetSvString(import, arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "immed")) {
					immed = SvTRUE(arg);
				} else {
					throw Exception::f("%s: unknown option '%s'", funcName, optname);
				}
			}

			if (from.empty() && fromNexus.empty())
				throw Exception::f("%s: one of options 'from' or 'fromNexus' must be not empty", funcName);
			if (fromTriead.empty() ^ fromNexus.empty())
				throw Exception::f("%s: options 'fromTriead' and 'fromNexus' must be both either empty or not", funcName);

			if (!from.empty()) {
				// break up into the Triead and Nexus parts
				size_t slash = from.find('/');
				if (slash == string::npos)
					throw Exception::f("%s: option 'from' must contain the thread and nexus names separated by '/', got '%s'", funcName, from.c_str());
				fromTriead = from.substr(0, slash);
				fromNexus = from.substr(slash + 1);
				if (fromTriead.empty())
					throw Exception::f("%s: empty thread name part in option 'from' (containing '%s')", funcName, from.c_str());
				if (fromNexus.empty())
					throw Exception::f("%s: empty nexus name part in option 'from' (containing '%s')", funcName, from.c_str());
			}

			std::transform(import.begin(), import.end(), import.begin(), ::tolower);
			if (import.compare(0, 5, "write") == 0) {
				writer = true;
			} else if (import.compare(0, 4, "read") == 0) {
				writer = false;
			} else {
				throw Exception::f("%s: the option 'import' must have the value one of 'writer', 'reader'; got '%s'", funcName, import.c_str());
			}

			Autoref<Facet> fa;
			try {
				fa = to->importNexus(fromTriead, fromNexus, as, writer, immed);
			} catch (Exception e) {
				throw Exception(e, strprintf("%s: invalid arguments:", funcName));
			}

			RETVAL = new WrapFacet(fa);
		} while(0); } TRICEPS_CATCH_CROAK;

#line 1006 "TrieadOwner.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_exports); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_exports)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::exports(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::exports(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 583 "TrieadOwner.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::Nexus";
		clearErrMsg();
		Triead *t = self->get()->get();
		Triead::NexusMap m;
		t->exports(m);
		for (Triead::NexusMap::iterator it = m.begin(); it != m.end(); ++it) {
			XPUSHs(sv_2mortal(newSVpvn(it->first.c_str(), it->first.size())));

			SV *sub = newSV(0);
			sv_setref_pv( sub, CLASS, (void*)(new WrapNexus(it->second)) );
			XPUSHs(sv_2mortal(sub));
		}
#line 1049 "TrieadOwner.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__TrieadOwner_imports); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_imports)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::imports(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::imports(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 603 "TrieadOwner.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::Facet";
		clearErrMsg();
		TrieadOwner *to = self->get();
		TrieadOwner::FacetMap m;
		to->imports(m);
		for (TrieadOwner::FacetMap::iterator it = m.begin(); it != m.end(); ++it) {
			XPUSHs(sv_2mortal(newSVpvn(it->first.c_str(), it->first.size())));

			SV *sub = newSV(0);
			sv_setref_pv( sub, CLASS, (void*)(new WrapFacet(it->second)) );
			XPUSHs(sv_2mortal(sub));
		}
#line 1091 "TrieadOwner.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__TrieadOwner_flushWriters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_flushWriters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::flushWriters(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::flushWriters(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 620 "TrieadOwner.xs"
		clearErrMsg();
		RETVAL = 0;
		try { do {
			RETVAL = self->get()->flushWriters();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1124 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_requestMyselfDead); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_requestMyselfDead)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::requestMyselfDead(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::requestMyselfDead(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 631 "TrieadOwner.xs"
		clearErrMsg();
		TrieadOwner *to = self->get();
		try { do {
			to->requestMyselfDead();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1155 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_nextXtray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_nextXtray)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::nextXtray(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::nextXtray(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 642 "TrieadOwner.xs"
		clearErrMsg();
		RETVAL = 0;
		try { do {
			RETVAL = self->get()->nextXtray();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1187 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_nextXtrayNoWait); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_nextXtrayNoWait)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::nextXtrayNoWait(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::nextXtrayNoWait(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 653 "TrieadOwner.xs"
		clearErrMsg();
		RETVAL = 0;
		try { do {
			RETVAL = self->get()->nextXtrayNoWait();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1220 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_nextXtrayTimeLimit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_nextXtrayTimeLimit)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, limit");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;
	double	limit = (double)SvNV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::nextXtrayTimeLimit(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::nextXtrayTimeLimit(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 665 "TrieadOwner.xs"
		clearErrMsg();
		RETVAL = 0;
		try { do {
			timespec tm;
			tm.tv_sec = (int64_t)limit;
			tm.tv_nsec = (limit - (int64_t)limit)*1000000000;
			RETVAL = self->get()->nextXtray(true, tm);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1258 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_nextXtrayTimeout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_nextXtrayTimeout)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, tout");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;
	double	tout = (double)SvNV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::nextXtrayTimeout(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::nextXtrayTimeout(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 680 "TrieadOwner.xs"
		clearErrMsg();
		RETVAL = 0;
		try { do {
			int64_t sec = (int64_t)tout;
			int32_t nsec = (tout - (int64_t)tout)*1000000000;
			RETVAL = self->get()->nextXtrayTimeout(sec, nsec);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1295 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_mainLoop); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_mainLoop)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::mainLoop(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::mainLoop(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 693 "TrieadOwner.xs"
		clearErrMsg();
		try { do {
			self->get()->mainLoop();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1325 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_isRqDrain); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_isRqDrain)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	bool	RETVAL;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::isRqDrain(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::isRqDrain(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 701 "TrieadOwner.xs"
		clearErrMsg();
		RETVAL = 0;
		try { do {
			RETVAL = self->get()->isRqDrain();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1356 "TrieadOwner.c"
	ST(0) = sv_newmortal();
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_requestDrainShared); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_requestDrainShared)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::requestDrainShared(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::requestDrainShared(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 712 "TrieadOwner.xs"
		clearErrMsg();
		try { do {
			self->get()->requestDrainShared();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1387 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_requestDrainExclusive); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_requestDrainExclusive)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::requestDrainExclusive(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::requestDrainExclusive(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 720 "TrieadOwner.xs"
		clearErrMsg();
		try { do {
			self->get()->requestDrainExclusive();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1416 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_waitDrain); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_waitDrain)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::waitDrain(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::waitDrain(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 728 "TrieadOwner.xs"
		clearErrMsg();
		try { do {
			self->get()->waitDrain();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1445 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_isDrained); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_isDrained)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	bool	RETVAL;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::isDrained(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::isDrained(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 737 "TrieadOwner.xs"
		clearErrMsg();
		RETVAL = 0;
		try { do {
			RETVAL = self->get()->isDrained();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1476 "TrieadOwner.c"
	ST(0) = sv_newmortal();
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_drainShared); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_drainShared)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::drainShared(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::drainShared(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 748 "TrieadOwner.xs"
		clearErrMsg();
		try { do {
			self->get()->drainShared();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1507 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_drainExclusive); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_drainExclusive)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::drainExclusive(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::drainExclusive(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 756 "TrieadOwner.xs"
		clearErrMsg();
		try { do {
			self->get()->drainExclusive();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1536 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_undrain); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_undrain)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::undrain(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::undrain(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 764 "TrieadOwner.xs"
		clearErrMsg();
		try { do {
			self->get()->undrain();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1565 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_addUnit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_addUnit)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, wu");
    {
	WrapTrieadOwner *	self;
	WrapUnit *	wu;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::addUnit(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::addUnit(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		wu = (WrapUnit *)SvIV((SV*)SvRV( ST(1) ));
		if (wu == 0 || wu->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::addUnit(): wu has an incorrect magic for WrapUnitPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::addUnit(): wu is not a blessed SV reference to WrapUnitPtr" );
	}
;
#line 772 "TrieadOwner.xs"
		clearErrMsg();
		try { do {
			self->get()->addUnit(wu->get());
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1605 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_forgetUnit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_forgetUnit)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, wu");
    {
	int	RETVAL;
	dXSTARG;
	WrapTrieadOwner *	self;
	WrapUnit *	wu;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::forgetUnit(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::forgetUnit(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		wu = (WrapUnit *)SvIV((SV*)SvRV( ST(1) ));
		if (wu == 0 || wu->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::forgetUnit(): wu has an incorrect magic for WrapUnitPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::forgetUnit(): wu is not a blessed SV reference to WrapUnitPtr" );
	}
;
#line 780 "TrieadOwner.xs"
		clearErrMsg();
		RETVAL = 0;
		try { do {
			RETVAL = self->get()->forgetUnit(wu->get())? 1 : 0;
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1648 "TrieadOwner.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__TrieadOwner_listUnits); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_listUnits)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	WrapTrieadOwner *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::listUnits(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::listUnits(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 791 "TrieadOwner.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::Unit";
		clearErrMsg();
		const TrieadOwner::UnitList &lst = self->get()->listUnits();
		for (TrieadOwner::UnitList::const_iterator it = lst.begin(); it != lst.end(); ++it) {
			SV *sub = newSV(0);
			sv_setref_pv( sub, CLASS, (void*)(new WrapUnit(*it)) );
			XPUSHs(sv_2mortal(sub));
		}
#line 1686 "TrieadOwner.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__TrieadOwner_trackFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_trackFd)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, fd");
    {
	WrapTrieadOwner *	self;
	int	fd = (int)SvIV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::trackFd(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::trackFd(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 807 "TrieadOwner.xs"
		clearErrMsg();
		try { do {
			self->get()->fileInterrupt_->trackFd(fd);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1718 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_forgetFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_forgetFd)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, fd");
    {
	WrapTrieadOwner *	self;
	int	fd = (int)SvIV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::forgetFd(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::forgetFd(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 815 "TrieadOwner.xs"
		clearErrMsg();
		try { do {
			self->get()->fileInterrupt_->forgetFd(fd);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1749 "TrieadOwner.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__TrieadOwner_makeTrackedFileFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__TrieadOwner_makeTrackedFileFd)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, file, fd");
    {
	WrapTrackedFile *	RETVAL;
	WrapTrieadOwner *	self;
	SV *	file = ST(1)
;
	int	fd = (int)SvIV(ST(2))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTrieadOwner *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::TrieadOwner::makeTrackedFileFd(): self has an incorrect magic for WrapTrieadOwnerPtr" );
		}
	} else{
		croakWithMsg( "Triceps::TrieadOwner::makeTrackedFileFd(): self is not a blessed SV reference to WrapTrieadOwnerPtr" );
	}
;
#line 825 "TrieadOwner.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::TrackedFile";
		clearErrMsg();

		try { do {
			self->get()->fileInterrupt_->trackFd(fd);
		} while(0); } TRICEPS_CATCH_CROAK;
		RETVAL = new WrapTrackedFile(self->get(), file, fd);
#line 1787 "TrieadOwner.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Triceps__TrieadOwner); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Triceps__TrieadOwner)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("Triceps::TrieadOwner::CLONE_SKIP", XS_Triceps__TrieadOwner_CLONE_SKIP, file);
        newXS("Triceps::TrieadOwner::DESTROY", XS_Triceps__TrieadOwner_DESTROY, file);
        newXS("Triceps::TrieadOwner::new", XS_Triceps__TrieadOwner_new, file);
        newXS("Triceps::TrieadOwner::app", XS_Triceps__TrieadOwner_app, file);
        newXS("Triceps::TrieadOwner::unit", XS_Triceps__TrieadOwner_unit, file);
        newXS("Triceps::TrieadOwner::markConstructed", XS_Triceps__TrieadOwner_markConstructed, file);
        newXS("Triceps::TrieadOwner::markReady", XS_Triceps__TrieadOwner_markReady, file);
        newXS("Triceps::TrieadOwner::readyReady", XS_Triceps__TrieadOwner_readyReady, file);
        newXS("Triceps::TrieadOwner::markDead", XS_Triceps__TrieadOwner_markDead, file);
        newXS("Triceps::TrieadOwner::abort", XS_Triceps__TrieadOwner_abort, file);
        newXS("Triceps::TrieadOwner::get", XS_Triceps__TrieadOwner_get, file);
        newXS("Triceps::TrieadOwner::isRqDead", XS_Triceps__TrieadOwner_isRqDead, file);
        newXS("Triceps::TrieadOwner::getName", XS_Triceps__TrieadOwner_getName, file);
        newXS("Triceps::TrieadOwner::fragment", XS_Triceps__TrieadOwner_fragment, file);
        newXS("Triceps::TrieadOwner::isConstructed", XS_Triceps__TrieadOwner_isConstructed, file);
        newXS("Triceps::TrieadOwner::isReady", XS_Triceps__TrieadOwner_isReady, file);
        newXS("Triceps::TrieadOwner::isDead", XS_Triceps__TrieadOwner_isDead, file);
        newXS("Triceps::TrieadOwner::isInputOnly", XS_Triceps__TrieadOwner_isInputOnly, file);
        newXS("Triceps::TrieadOwner::makeNexus", XS_Triceps__TrieadOwner_makeNexus, file);
        newXS("Triceps::TrieadOwner::importNexus", XS_Triceps__TrieadOwner_importNexus, file);
        newXS("Triceps::TrieadOwner::exports", XS_Triceps__TrieadOwner_exports, file);
        newXS("Triceps::TrieadOwner::imports", XS_Triceps__TrieadOwner_imports, file);
        newXS("Triceps::TrieadOwner::flushWriters", XS_Triceps__TrieadOwner_flushWriters, file);
        newXS("Triceps::TrieadOwner::requestMyselfDead", XS_Triceps__TrieadOwner_requestMyselfDead, file);
        newXS("Triceps::TrieadOwner::nextXtray", XS_Triceps__TrieadOwner_nextXtray, file);
        newXS("Triceps::TrieadOwner::nextXtrayNoWait", XS_Triceps__TrieadOwner_nextXtrayNoWait, file);
        newXS("Triceps::TrieadOwner::nextXtrayTimeLimit", XS_Triceps__TrieadOwner_nextXtrayTimeLimit, file);
        newXS("Triceps::TrieadOwner::nextXtrayTimeout", XS_Triceps__TrieadOwner_nextXtrayTimeout, file);
        newXS("Triceps::TrieadOwner::mainLoop", XS_Triceps__TrieadOwner_mainLoop, file);
        newXS("Triceps::TrieadOwner::isRqDrain", XS_Triceps__TrieadOwner_isRqDrain, file);
        newXS("Triceps::TrieadOwner::requestDrainShared", XS_Triceps__TrieadOwner_requestDrainShared, file);
        newXS("Triceps::TrieadOwner::requestDrainExclusive", XS_Triceps__TrieadOwner_requestDrainExclusive, file);
        newXS("Triceps::TrieadOwner::waitDrain", XS_Triceps__TrieadOwner_waitDrain, file);
        newXS("Triceps::TrieadOwner::isDrained", XS_Triceps__TrieadOwner_isDrained, file);
        newXS("Triceps::TrieadOwner::drainShared", XS_Triceps__TrieadOwner_drainShared, file);
        newXS("Triceps::TrieadOwner::drainExclusive", XS_Triceps__TrieadOwner_drainExclusive, file);
        newXS("Triceps::TrieadOwner::undrain", XS_Triceps__TrieadOwner_undrain, file);
        newXS("Triceps::TrieadOwner::addUnit", XS_Triceps__TrieadOwner_addUnit, file);
        newXS("Triceps::TrieadOwner::forgetUnit", XS_Triceps__TrieadOwner_forgetUnit, file);
        newXS("Triceps::TrieadOwner::listUnits", XS_Triceps__TrieadOwner_listUnits, file);
        newXS("Triceps::TrieadOwner::trackFd", XS_Triceps__TrieadOwner_trackFd, file);
        newXS("Triceps::TrieadOwner::forgetFd", XS_Triceps__TrieadOwner_forgetFd, file);
        newXS("Triceps::TrieadOwner::makeTrackedFileFd", XS_Triceps__TrieadOwner_makeTrackedFileFd, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

