/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of App.xs. Do not edit this file, edit App.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "App.xs"
//
// (C) Copyright 2011-2014 Sergey A. Babkin.
// This file is a part of Triceps.
// See the file COPYRIGHT for the copyright notice and license information
//
// The wrapper for App.

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include "TricepsPerl.h"
#include "PerlApp.h"
#include "app/App.h"

#line 28 "App.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 170 "App.c"

XS_EUPXS(XS_Triceps__App_CLONE_SKIP); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_CLONE_SKIP)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 24 "App.xs"
		RETVAL = 1;
#line 182 "App.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapApp *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapApp *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::App::DESTROY(): self has an incorrect magic for WrapAppPtr" );
		}
	} else{
		croakWithMsg( "Triceps::App::DESTROY(): self is not a blessed SV reference to WrapAppPtr" );
	}
;
#line 31 "App.xs"
		App *app = self->get();
		// warn("App %s %p wrap %p destroyed!", app->getName().c_str(), app, self);
		delete self;
#line 211 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_make); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_make)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	WrapApp *	RETVAL;
	char *	name = (char *)SvPV_nolen(ST(0))
;
#line 39 "App.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::App";

		clearErrMsg();
		RETVAL = NULL; // shut up the warning

		try { do {
			Autoref<App> app ;
			app = App::make(name);
			// warn("Created app %s %p wrap %p", name, app.get(), wa);
			RETVAL = new WrapApp(app);
		} while(0); } TRICEPS_CATCH_CROAK;

#line 241 "App.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_find); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_find)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	WrapApp *	RETVAL;
	char *	name = (char *)SvPV_nolen(ST(0))
;
#line 58 "App.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::App";

		clearErrMsg();
		RETVAL = NULL; // shut up the warning

		try { do {
			Autoref<App> app ;
			app = App::find(name);
			RETVAL = new WrapApp(app);
		} while(0); } TRICEPS_CATCH_CROAK;

#line 272 "App.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_resolve); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_resolve)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	WrapApp *	RETVAL;
	SV *	app = ST(0)
;
#line 86 "App.xs"
		// for casting of return value
		static char funcName[] =  "Triceps::App::resolve";
		static char CLASS[] = "Triceps::App";
		clearErrMsg();
		RETVAL = NULL; // shut up the warning

		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			RETVAL = new WrapApp(appv);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 303 "App.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_drop); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_drop)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	SV *	app = ST(0)
;
#line 106 "App.xs"
		static char funcName[] =  "Triceps::App::drop";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			App::drop(appv);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 328 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_listApps); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_listApps)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
#line 117 "App.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::App";

		clearErrMsg();
		App::Map m;
		App::listApps(m);
		for (App::Map::iterator it = m.begin(); it != m.end(); ++it) {
			XPUSHs(sv_2mortal(newSVpvn(it->first.c_str(), it->first.size())));

			SV *sub = newSV(0);
			sv_setref_pv( sub, CLASS, (void*)(new WrapApp(it->second)) );
			XPUSHs(sv_2mortal(sub));
		}
#line 358 "App.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__App_same); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_same)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	int	RETVAL;
	dXSTARG;
	WrapApp *	self;
	WrapApp *	other;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapApp *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::App::same(): self has an incorrect magic for WrapAppPtr" );
		}
	} else{
		croakWithMsg( "Triceps::App::same(): self is not a blessed SV reference to WrapAppPtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		other = (WrapApp *)SvIV((SV*)SvRV( ST(1) ));
		if (other == 0 || other->badMagic()) {
			croakWithMsg( "Triceps::App::same(): other has an incorrect magic for WrapAppPtr" );
		}
	} else{
		croakWithMsg( "Triceps::App::same(): other is not a blessed SV reference to WrapAppPtr" );
	}
;
#line 135 "App.xs"
		clearErrMsg();
		App *a1 = self->get();
		App *a2 = other->get();
		RETVAL = (a1 == a2);
#line 401 "App.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_getName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_getName)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	char *	RETVAL;
	dXSTARG;
	WrapApp *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapApp *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::App::getName(): self has an incorrect magic for WrapAppPtr" );
		}
	} else{
		croakWithMsg( "Triceps::App::getName(): self is not a blessed SV reference to WrapAppPtr" );
	}
;
#line 145 "App.xs"
		clearErrMsg();
		App *a = self->get();
		RETVAL = (char *)a->getName().c_str();
#line 432 "App.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_isAborted); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_isAborted)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	int	RETVAL;
	dXSTARG;
	SV *	app = ST(0)
;
#line 154 "App.xs"
		static char funcName[] =  "Triceps::App::isAborted";
		clearErrMsg();
		RETVAL = 0;
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			RETVAL = appv->isAborted();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 459 "App.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_getAborted); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_getAborted)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	SV *	app = ST(0)
;
#line 170 "App.xs"
		// for casting of return value
		static char funcName[] =  "Triceps::App::getAborted";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);

			if (!appv->isAborted()) {
				XPUSHs(sv_2mortal(newSV(0)));
				XPUSHs(sv_2mortal(newSV(0)));
			} else {
				string t = appv->getAbortedBy();
				string m = appv->getAbortedMsg();

				XPUSHs(sv_2mortal(newSVpvn(t.c_str(), t.size())));
				XPUSHs(sv_2mortal(newSVpvn(m.c_str(), m.size())));

				SV *sub = newSV(0); // undef by default
				XPUSHs(sv_2mortal(sub));
			}
		} while(0); } TRICEPS_CATCH_CROAK;
#line 500 "App.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__App_abortBy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_abortBy)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "app, tname, msg");
    {
	SV *	app = ST(0)
;
	char *	tname = (char *)SvPV_nolen(ST(1))
;
	char *	msg = (char *)SvPV_nolen(ST(2))
;
#line 195 "App.xs"
		static char funcName[] =  "Triceps::App::abortBy";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			appv->abortBy(tname, msg);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 528 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_setDeadline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_setDeadline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "app, deadline");
    {
	SV *	app = ST(0)
;
	int	deadline = (int)SvIV(ST(1))
;
#line 207 "App.xs"
		static char funcName[] =  "Triceps::App::setDeadline";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);

			timespec dl;
			dl.tv_sec = deadline;
			dl.tv_nsec = 0;
			appv->setDeadline(dl);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 557 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_setTimeout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_setTimeout)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "app, main_to, ...");
    {
	SV *	app = ST(0)
;
	int	main_to = (int)SvIV(ST(1))
;
#line 222 "App.xs"
		static char funcName[] =  "Triceps::App::setTimeout";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);

			if (items > 3) {
				throw Exception::f("Usage: %s(app, main_to, [frag_to]), too many arguments", funcName);
			}

			int frag_to = -1;
			if (items == 3) {
				frag_to = SvIV(ST(2));
			}

			appv->setTimeout(main_to, frag_to);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 592 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_refreshDeadline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_refreshDeadline)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	SV *	app = ST(0)
;
#line 243 "App.xs"
		static char funcName[] =  "Triceps::App::refreshDeadline";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			appv->refreshDeadline();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 615 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_declareTriead); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_declareTriead)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "app, tname");
    {
	SV *	app = ST(0)
;
	char *	tname = (char *)SvPV_nolen(ST(1))
;
#line 255 "App.xs"
		static char funcName[] =  "Triceps::App::declareTriead";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			appv->declareTriead(tname);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 640 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_getTrieads); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_getTrieads)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	SV *	app = ST(0)
;
#line 266 "App.xs"
		// for casting of return value
		static char funcName[] =  "Triceps::App::getTrieads";
		static char CLASS[] = "Triceps::Triead";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);

			App::TrieadMap m;
			appv->getTrieads(m);
			for (App::TrieadMap::iterator it = m.begin(); it != m.end(); ++it) {
				XPUSHs(sv_2mortal(newSVpvn(it->first.c_str(), it->first.size())));

				SV *sub = newSV(0); // undef by default
				if (!it->second.isNull())
					sv_setref_pv( sub, CLASS, (void*)(new WrapTriead(it->second)) );
				XPUSHs(sv_2mortal(sub));
			}
		} while(0); } TRICEPS_CATCH_CROAK;
#line 678 "App.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__App_harvestOnce); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_harvestOnce)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapApp *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapApp *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::App::harvestOnce(): self has an incorrect magic for WrapAppPtr" );
		}
	} else{
		croakWithMsg( "Triceps::App::harvestOnce(): self is not a blessed SV reference to WrapAppPtr" );
	}
;
#line 293 "App.xs"
		clearErrMsg();
		App *a = self->get();
		RETVAL = 0;
		try { do {
			RETVAL = (int)a->harvestOnce();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 712 "App.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_waitNeedHarvest); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_waitNeedHarvest)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapApp *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapApp *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::App::waitNeedHarvest(): self has an incorrect magic for WrapAppPtr" );
		}
	} else{
		croakWithMsg( "Triceps::App::waitNeedHarvest(): self is not a blessed SV reference to WrapAppPtr" );
	}
;
#line 305 "App.xs"
		clearErrMsg();
		App *a = self->get();
		try { do {
			a->waitNeedHarvest();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 743 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_harvester); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_harvester)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	WrapApp *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapApp *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::App::harvester(): self has an incorrect magic for WrapAppPtr" );
		}
	} else{
		croakWithMsg( "Triceps::App::harvester(): self is not a blessed SV reference to WrapAppPtr" );
	}
;
#line 320 "App.xs"
		static char funcName[] =  "Triceps::App::harvester";
		clearErrMsg();
		App *a = self->get();
		try { do {
			bool throwAbort = true;

			if (items % 2 != 1) {
				throw Exception::f("Usage: %s(app, optionName, optionValue, ...), option names and values must go in pairs", funcName);
			}
			for (int i = 1; i < items; i += 2) {
				const char *optname = (const char *)SvPV_nolen(ST(i));
				SV *arg = ST(i+1);
				if (!strcmp(optname, "die_on_abort")) {
					throwAbort = SvTRUE(arg);
				} else {
					throw Exception::f("%s: unknown option '%s'", funcName, optname);
				}
			}

			a->harvester(throwAbort);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 789 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_DEFAULT_TIMEOUT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_DEFAULT_TIMEOUT)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 346 "App.xs"
		RETVAL = App::DEFAULT_TIMEOUT;
#line 806 "App.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_isDead); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_isDead)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	int	RETVAL;
	dXSTARG;
	SV *	app = ST(0)
;
#line 353 "App.xs"
		static char funcName[] =  "Triceps::App::isDead";
		clearErrMsg();
		RETVAL = 0;
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			RETVAL = appv->isDead();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 833 "App.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_isShutdown); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_isShutdown)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	int	RETVAL;
	dXSTARG;
	SV *	app = ST(0)
;
#line 367 "App.xs"
		static char funcName[] =  "Triceps::App::isShutdown";
		clearErrMsg();
		RETVAL = 0;
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			RETVAL = appv->isShutdown();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 860 "App.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_waitDead); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_waitDead)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapApp *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapApp *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::App::waitDead(): self has an incorrect magic for WrapAppPtr" );
		}
	} else{
		croakWithMsg( "Triceps::App::waitDead(): self is not a blessed SV reference to WrapAppPtr" );
	}
;
#line 383 "App.xs"
		clearErrMsg();
		try { do {
			self->get()->waitDead();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 890 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_shutdown); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_shutdown)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	SV *	app = ST(0)
;
#line 391 "App.xs"
		static char funcName[] =  "Triceps::App::shutdown";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			appv->shutdown();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 913 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_shutdownFragment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_shutdownFragment)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "app, fragname");
    {
	SV *	app = ST(0)
;
	char *	fragname = (char *)SvPV_nolen(ST(1))
;
#line 402 "App.xs"
		static char funcName[] =  "Triceps::App::shutdownFragment";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			appv->shutdownFragment(fragname);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 938 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_requestDrain); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_requestDrain)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	SV *	app = ST(0)
;
#line 415 "App.xs"
		static char funcName[] =  "Triceps::App::requestDrain";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			appv->requestDrain();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 961 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_waitDrain); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_waitDrain)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	SV *	app = ST(0)
;
#line 426 "App.xs"
		static char funcName[] =  "Triceps::App::waitDrain";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			appv->waitDrain();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 984 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_drain); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_drain)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	SV *	app = ST(0)
;
#line 437 "App.xs"
		static char funcName[] =  "Triceps::App::drain";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			appv->drain();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1007 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_undrain); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_undrain)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	SV *	app = ST(0)
;
#line 448 "App.xs"
		static char funcName[] =  "Triceps::App::undrain";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			appv->undrain();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1030 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_isDrained); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_isDrained)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "app");
    {
	int	RETVAL;
	dXSTARG;
	SV *	app = ST(0)
;
#line 459 "App.xs"
		static char funcName[] =  "Triceps::App::isDrained";
		clearErrMsg();
		RETVAL = 0;
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			RETVAL = appv->isDrained();
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1056 "App.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__App_storeFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_storeFd)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "app, name, fd, className");
    {
	SV *	app = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
	int	fd = (int)SvIV(ST(2))
;
	char *	className = (char *)SvPV_nolen(ST(3))
;
#line 474 "App.xs"
		static char funcName[] =  "Triceps::App::storeFd";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			int dupfd = dup(fd);
			if (dupfd < 0)
				throw Exception::f("%s: dup failed: %s", funcName, strerror(errno));
			try {
				appv->storeFd(name, dupfd, className); // may throw
			} catch (Exception e) {
				close(dupfd);
				throw;
			}
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1094 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_loadFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_loadFd)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "app, name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	SV *	app = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
#line 494 "App.xs"
		static char funcName[] =  "Triceps::App::loadFd";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			string className;
			int fd = appv->loadFd(name, &className);
			if (fd < 0)
				throw Exception::f("%s: unknown file descriptor '%s'", funcName, name);

			XPUSHs(sv_2mortal(newSViv(fd)));
			XPUSHs(sv_2mortal(newSVpvn(className.c_str(), className.size())));
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1128 "App.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__App_loadDupFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_loadDupFd)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "app, name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	SV *	app = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
#line 514 "App.xs"
		static char funcName[] =  "Triceps::App::loadDupFd";
		clearErrMsg();
		RETVAL = 0;
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			string className;
			int fd = appv->loadFd(name, &className);
			if (fd < 0)
				throw Exception::f("%s: unknown file descriptor '%s'", funcName, name);
			fd = dup(fd);
			if (fd < 0)
				throw Exception::f("%s: dup failed: %s", funcName, strerror(errno));

			XPUSHs(sv_2mortal(newSViv(fd)));
			XPUSHs(sv_2mortal(newSVpvn(className.c_str(), className.size())));
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1167 "App.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__App_forgetFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_forgetFd)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "app, name");
    {
	SV *	app = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
#line 536 "App.xs"
		static char funcName[] =  "Triceps::App::forgetFd";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			if (!appv->forgetFd(name))
				throw Exception::f("%s: unknown file descriptor '%s'", funcName, name);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1194 "App.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__App_closeFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__App_closeFd)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "app, name");
    {
	SV *	app = ST(0)
;
	char *	name = (char *)SvPV_nolen(ST(1))
;
#line 549 "App.xs"
		static char funcName[] =  "Triceps::App::closeFd";
		clearErrMsg();
		try { do {
			Autoref<App> appv;
			parseApp(funcName, "app", app, appv);
			if (!appv->closeFd(name))
				throw Exception::f("%s: unknown file descriptor '%s'", funcName, name);
			if (errno != 0)
				throw Exception::f("%s: failed to close file descriptor '%s': %s", funcName, name, strerror(errno));
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1222 "App.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Triceps__App); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Triceps__App)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("Triceps::App::CLONE_SKIP", XS_Triceps__App_CLONE_SKIP, file);
        newXS("Triceps::App::DESTROY", XS_Triceps__App_DESTROY, file);
        newXS("Triceps::App::make", XS_Triceps__App_make, file);
        newXS("Triceps::App::find", XS_Triceps__App_find, file);
        newXS("Triceps::App::resolve", XS_Triceps__App_resolve, file);
        newXS("Triceps::App::drop", XS_Triceps__App_drop, file);
        newXS("Triceps::App::listApps", XS_Triceps__App_listApps, file);
        newXS("Triceps::App::same", XS_Triceps__App_same, file);
        newXS("Triceps::App::getName", XS_Triceps__App_getName, file);
        newXS("Triceps::App::isAborted", XS_Triceps__App_isAborted, file);
        newXS("Triceps::App::getAborted", XS_Triceps__App_getAborted, file);
        newXS("Triceps::App::abortBy", XS_Triceps__App_abortBy, file);
        newXS("Triceps::App::setDeadline", XS_Triceps__App_setDeadline, file);
        newXS("Triceps::App::setTimeout", XS_Triceps__App_setTimeout, file);
        newXS("Triceps::App::refreshDeadline", XS_Triceps__App_refreshDeadline, file);
        newXS("Triceps::App::declareTriead", XS_Triceps__App_declareTriead, file);
        newXS("Triceps::App::getTrieads", XS_Triceps__App_getTrieads, file);
        newXS("Triceps::App::harvestOnce", XS_Triceps__App_harvestOnce, file);
        newXS("Triceps::App::waitNeedHarvest", XS_Triceps__App_waitNeedHarvest, file);
        newXS("Triceps::App::harvester", XS_Triceps__App_harvester, file);
        newXS("Triceps::App::DEFAULT_TIMEOUT", XS_Triceps__App_DEFAULT_TIMEOUT, file);
        newXS("Triceps::App::isDead", XS_Triceps__App_isDead, file);
        newXS("Triceps::App::isShutdown", XS_Triceps__App_isShutdown, file);
        newXS("Triceps::App::waitDead", XS_Triceps__App_waitDead, file);
        newXS("Triceps::App::shutdown", XS_Triceps__App_shutdown, file);
        newXS("Triceps::App::shutdownFragment", XS_Triceps__App_shutdownFragment, file);
        newXS("Triceps::App::requestDrain", XS_Triceps__App_requestDrain, file);
        newXS("Triceps::App::waitDrain", XS_Triceps__App_waitDrain, file);
        newXS("Triceps::App::drain", XS_Triceps__App_drain, file);
        newXS("Triceps::App::undrain", XS_Triceps__App_undrain, file);
        newXS("Triceps::App::isDrained", XS_Triceps__App_isDrained, file);
        newXS("Triceps::App::storeFd", XS_Triceps__App_storeFd, file);
        newXS("Triceps::App::loadFd", XS_Triceps__App_loadFd, file);
        newXS("Triceps::App::loadDupFd", XS_Triceps__App_loadDupFd, file);
        newXS("Triceps::App::forgetFd", XS_Triceps__App_forgetFd, file);
        newXS("Triceps::App::closeFd", XS_Triceps__App_closeFd, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

