/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of FnBinding.xs. Do not edit this file, edit FnBinding.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "FnBinding.xs"
//
// (C) Copyright 2011-2014 Sergey A. Babkin.
// This file is a part of Triceps.
// See the file COPYRIGHT for the copyright notice and license information
//
// The wrapper for FnBinding.

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include "TricepsPerl.h"
#include "TricepsOpt.h"
#include "PerlCallback.h"


// Build a binding from components.
// Throws an Exception on errors.
//
// @param funcName - name of the calling function, for error messages.
// @param name - name of the FnBinding object to create.
// @param u - unit for creation of labels in the FnBinding.
// @param fnr - function return to bind to.
// @param labels - definition of labels in the bindings (a Perl array of elements that are
//        either label objects or code snippets)
// @param clearLabels - flag: on binding destruction automatically clear the labels that
//        have been passed as ready labels (the ones created from code snippets are always
//        cleared)
// @return - the creaed binding.
static Onceref<FnBinding> makeBinding(const char *funcName, const string &name, Unit *u, FnReturn *fnr, AV *labels, bool clearLabels)
{
	Autoref<FnBinding> fbind = new FnBinding(name, fnr);

	// parse labels, and create labels around the code snippets
	int len = av_len(labels)+1; // av_len returns the index of last element
	if (len % 2 != 0) // 0 elements is OK
		throw Exception(strprintf("%s: option 'labels' must contain elements in pairs, has %d elements", funcName, len), false);
	for (int i = 0; i < len; i+=2) {
		SV *svname, *svval;
		svname = *av_fetch(labels, i, 0);
		svval = *av_fetch(labels, i+1, 0);
		string entryname;
		bool cl = clearLabels;

		GetSvString(entryname, svname, "%s: in option 'labels' element %d name", funcName, i/2+1);

		Autoref<Label> lb = GetSvLabelOrCode(svval, "%s: in option 'labels' element %d with name '%s'", 
			funcName, i/2+1, SvPV_nolen(svname));
		if (lb.isNull()) {
			// it's a code snippet, make a label
			if (u == NULL) {
				throw Exception(strprintf("%s: option 'unit' must be set to handle the code reference in option 'labels' element %d with name '%s'", 
					funcName, i/2+1, SvPV_nolen(svname)), false);
			}
			string lbname = name + "." + entryname;
			RowType *rt = fnr->getRowType(entryname);
			if (rt == NULL) {
				throw Exception(strprintf("%s: in option 'labels' element %d has an unknown return label name '%s'", 
					funcName, i/2+1, SvPV_nolen(svname)), false);
			}
			lb = PerlLabel::makeSimple(u, rt, lbname, svval, "%s: in option 'labels' element %d with name '%s'",
				funcName, i/2+1, SvPV_nolen(svname));
			cl = true; // always clear these
		}
		fbind->addLabel(entryname, lb, cl);
	}
	try {
		checkOrThrow(fbind);
	} catch (Exception e) {
		throw Exception(e, strprintf("%s: invalid arguments:", funcName));
	}

	return fbind;
}

#line 88 "FnBinding.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 230 "FnBinding.c"

XS_EUPXS(XS_Triceps__FnBinding_CLONE_SKIP); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_CLONE_SKIP)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 84 "FnBinding.xs"
		RETVAL = 1;
#line 242 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::DESTROY(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::DESTROY(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 141 "FnBinding.xs"
		// warn("FnBinding destroyed!");
		delete self;
#line 270 "FnBinding.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__FnBinding_same); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_same)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	int	RETVAL;
	dXSTARG;
	WrapFnBinding *	self;
	WrapFnBinding *	other;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::same(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::same(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		other = (WrapFnBinding *)SvIV((SV*)SvRV( ST(1) ));
		if (other == 0 || other->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::same(): other has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::same(): other is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 148 "FnBinding.xs"
		clearErrMsg();
		FnBinding *f = self->get();
		FnBinding *of = other->get();
		RETVAL = (f == of);
#line 312 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	WrapFnBinding *	RETVAL;
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
#line 161 "FnBinding.xs"
		static char funcName[] =  "Triceps::FnBinding::new";
		Autoref<FnBinding> fbind;
		clearErrMsg();
		try {
			clearErrMsg();
			Unit *u = NULL;
			AV *labels = NULL;
			string name;
			FnReturn *fnr = NULL;
			bool wtray = false;
			bool clearLabels = false;

			if (items % 2 != 1) {
				throw Exception("Usage: Triceps::FnBinding::new(CLASS, optionName, optionValue, ...), option names and values must go in pairs", false);
			}
			for (int i = 1; i < items; i += 2) {
				const char *optname = (const char *)SvPV_nolen(ST(i));
				SV *arg = ST(i+1);
				if (!strcmp(optname, "unit")) {
					u = TRICEPS_GET_WRAP(Unit, arg, "%s: option '%s'", funcName, optname)->get();
				} else if (!strcmp(optname, "name")) {
					GetSvString(name, arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "on")) {
					fnr = TRICEPS_GET_WRAP(FnReturn, arg, "%s: option '%s'", funcName, optname)->get();
				} else if (!strcmp(optname, "labels")) {
					labels = GetSvArray(arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "withTray")) {
					wtray = (SvIV(arg) != 0);
				} else if (!strcmp(optname, "clearLabels")) {
					clearLabels = (SvIV(arg) != 0);
				} else {
					throw Exception(strprintf("%s: unknown option '%s'", funcName, optname), false);
				}
			}

			if (name.empty())
				throw Exception(strprintf("%s: missing or empty mandatory option 'name'", funcName), false);
			if (fnr == NULL)
				throw Exception(strprintf("%s: missing mandatory option 'on'", funcName), false);
			if (labels == NULL)
				throw Exception(strprintf("%s: missing mandatory option 'labels'", funcName), false);

			// no exception may happen after makeBinding()
			fbind = makeBinding(funcName, name, u, fnr, labels, clearLabels);
			fbind->withTray(wtray);
		} TRICEPS_CATCH_CROAK;

		RETVAL = new WrapFnBinding(fbind);
#line 378 "FnBinding.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_call); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_call)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 219 "FnBinding.xs"
		static char funcName[] =  "Triceps::FnBinding::call";
		clearErrMsg();
		try {
			clearErrMsg();
			int len, i;
			Unit *u = NULL;
			AV *labels = NULL;
			string name;
			FnReturn *fnr = NULL;
			Rowop *rop = NULL;
			Tray *tray = NULL;
			AV *roparray = NULL; // array of rowops
			Autoref<PerlCallback> code = NULL;
			bool clearLabels = false;
			bool delayed = false;

			if (items % 2 != 0) {
				throw Exception::f("Usage: %s(optionName, optionValue, ...), option names and values must go in pairs", funcName);
			}
			for (int i = 0; i < items; i += 2) {
				const char *optname = (const char *)SvPV_nolen(ST(i));
				SV *arg = ST(i+1);
				if (!strcmp(optname, "unit")) {
					u = TRICEPS_GET_WRAP(Unit, arg, "%s: option '%s'", funcName, optname)->get();
				} else if (!strcmp(optname, "name")) {
					GetSvString(name, arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "on")) {
					fnr = TRICEPS_GET_WRAP(FnReturn, arg, "%s: option '%s'", funcName, optname)->get();
				} else if (!strcmp(optname, "labels")) {
					labels = GetSvArray(arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "rowop")) {
					rop = TRICEPS_GET_WRAP(Rowop, arg, "%s: option '%s'", funcName, optname)->get();
				} else if (!strcmp(optname, "tray")) {
					tray = TRICEPS_GET_WRAP(Tray, arg, "%s: option '%s'", funcName, optname)->get();
				} else if (!strcmp(optname, "rowops")) {
					roparray = GetSvArray(arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "code")) {
					code = GetSvCall(arg, "%s: option '%s'", funcName, optname);
				} else if (!strcmp(optname, "clearLabels")) {
					clearLabels = (SvIV(arg) != 0);
				} else if (!strcmp(optname, "delayed")) {
					delayed = (SvIV(arg) != 0);
				} else {
					throw Exception(strprintf("%s: unknown option '%s'", funcName, optname), false);
				}
			}

			if (u == NULL)
				throw Exception(strprintf("%s: missing mandatory option 'unit'", funcName), false);
			if (name.empty())
				throw Exception(strprintf("%s: missing or empty mandatory option 'name'", funcName), false);
			if (fnr == NULL)
				throw Exception(strprintf("%s: missing mandatory option 'on'", funcName), false);
			if (labels == NULL)
				throw Exception(strprintf("%s: missing mandatory option 'labels'", funcName), false);

			// the mutually exclusive ways to specify a rowop
			int rowop_spec = 0;
			if (rop != NULL) rowop_spec++;
			if (tray != NULL) rowop_spec++;
			if (roparray != NULL) rowop_spec++;
			if (!code.isNull()) rowop_spec++;

			if (rowop_spec != 1)
				throw Exception::f("%s: exactly 1 of options 'rowop', 'tray', 'rowops', 'code' must be specified, got %d of them.",
					funcName, rowop_spec);

			// create and set up the binding
			Autoref<FnBinding> fbind = makeBinding(funcName, name, u, fnr, labels, clearLabels);
			fbind->withTray(delayed);
			Autoref<AutoFnBind> ab = new AutoFnBind;
			ab->add(fnr, fbind);

			// call the labels
			if (roparray != NULL) {
				int len = av_len(roparray)+1; // av_len returns the index of last element
				for (int i = 0; i < len; i++) {
					SV *svop = *av_fetch(roparray, i, 0);
					u->call(TRICEPS_GET_WRAP(Rowop, svop, "%s: element %d of the option 'rowops' array", funcName, i)->get()); // not i+1 by design
				}
			} else if (rop) {
				u->call(rop);
			} else if (tray) {
				u->callTray(tray);
			} else if (!code.isNull()) {
				PerlCallbackStartCall(code);
				PerlCallbackDoCall(code);
				callbackSuccessOrThrow("Error detected in %s option 'code'", funcName);
			}

			// The bindings get popped. If the call above throws an exception, the
			// execution won't get here but it's not a problem: ab will be cleared
			// on leaving the block anyway. The only thing this code does is a nicer
			// reporting of popping order errors. But if there was another error
			// that caused a throw, the popping order errors become unimportant
			// and will be ignored.
			try {
				ab->clear();
			} catch(Exception e) {
				throw Exception::f(e, "%s: error on popping the bindings:", funcName);
			}

			if (delayed)
				fbind->callTray(); // after the bindings are popped, to avoid the possible loops
		} TRICEPS_CATCH_CROAK;

		RETVAL = 1;
#line 502 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_getName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_getName)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	char *	RETVAL;
	dXSTARG;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::getName(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::getName(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 332 "FnBinding.xs"
		clearErrMsg();
		RETVAL = (char *)self->get()->getName().c_str();
#line 532 "FnBinding.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_withTray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_withTray)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	int	RETVAL;
	dXSTARG;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::withTray(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::withTray(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 343 "FnBinding.xs"
		clearErrMsg();
		if (items != 1 && items != 2)
		   Perl_croak(aTHX_ "Usage: Triceps::FnBinding::withTray(self, [on])");
		FnBinding *bind = self->get();
		RETVAL = (bind->getTray() != NULL);
		if (items == 2) {
			IV on = SvIV(ST(1));
			bind->withTray((on != 0));
		}
#line 569 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_callTray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_callTray)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::callTray(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::callTray(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 360 "FnBinding.xs"
		clearErrMsg();
		try {
			self->get()->callTray();
		} TRICEPS_CATCH_CROAK;
		RETVAL = 1;
#line 602 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_traySize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_traySize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	IV	RETVAL;
	dXSTARG;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::traySize(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::traySize(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 372 "FnBinding.xs"
		clearErrMsg();
		Tray *tray = self->get()->getTray();
		RETVAL = (tray == NULL)? 0 : tray->size();
#line 633 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_trayEmpty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_trayEmpty)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	IV	RETVAL;
	dXSTARG;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::trayEmpty(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::trayEmpty(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 382 "FnBinding.xs"
		clearErrMsg();
		Tray *tray = self->get()->getTray();
		RETVAL = (tray == NULL || tray->size() == 0)? 1 : 0;
#line 664 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_swapTray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_swapTray)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTray *	RETVAL;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::swapTray(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::swapTray(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 393 "FnBinding.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::Tray";
		static char funcName[] =  "Triceps::FnBinding::swapTray";
		clearErrMsg();
		Unit *u = NULL;

		{ // first check the cheap way
			Tray *t = self->get()->getTray();
			if (t == NULL || t->empty())
				XSRETURN_UNDEF; // not a croak!
		}

		Autoref<Tray> ttret;
		try {
			Autoref<Tray> tt = self->get()->swapTray();
			const Label *lb;
			lb = (*tt)[0]->getLabel();
			u = lb->getUnitPtr();
			if (u == NULL)
				throw Exception::f("%s: tray contains a rowop for cleared label '%s'.", funcName, lb->getName().c_str());
			int n = tt->size();
			for (int i = 1; i < n; i++) {
				lb = (*tt)[i]->getLabel();
				Unit *u2 = lb->getUnitPtr();
				if (u2 == NULL)
					throw Exception::f("%s: tray contains a rowop for cleared label '%s'.", funcName, lb->getName().c_str());
				if (u2 != u)
					throw Exception::f("%s: tray contains a mix of rowops for units '%s' and '%s'.", 
						funcName, u->getName().c_str(), u2->getName().c_str());
			}
			ttret = tt; // no exceptions after this
		} TRICEPS_CATCH_CROAK;
		RETVAL = new WrapTray(u, ttret);
#line 724 "FnBinding.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_equals); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_equals)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	int	RETVAL;
	dXSTARG;
	WrapFnBinding *	self;
	SV *	other = ST(1)
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::equals(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::equals(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 433 "FnBinding.xs"
		static char funcName[] =  "Triceps::FnBinding::equals";
		clearErrMsg();
		WrapFnReturn *wret;
		WrapFnBinding *wbind;
		try {
			TRICEPS_GET_WRAP2(FnReturn, wret, FnBinding, wbind, other, "%s: argument", funcName);
		} TRICEPS_CATCH_CROAK;
		if (wret)
			RETVAL = self->get()->equals(wret->get());
		else
			RETVAL = self->get()->equals(wbind->get());
#line 766 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_match); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_match)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	int	RETVAL;
	dXSTARG;
	WrapFnBinding *	self;
	SV *	other = ST(1)
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::match(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::match(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 450 "FnBinding.xs"
		static char funcName[] =  "Triceps::FnBinding::match";
		clearErrMsg();
		WrapFnReturn *wret;
		WrapFnBinding *wbind;
		try {
			TRICEPS_GET_WRAP2(FnReturn, wret, FnBinding, wbind, other, "%s: argument", funcName);
		} TRICEPS_CATCH_CROAK;
		if (wret)
			RETVAL = self->get()->match(wret->get());
		else
			RETVAL = self->get()->match(wbind->get());
#line 807 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::size(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::size(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 469 "FnBinding.xs"
		clearErrMsg();
		RETVAL = self->get()->size();
#line 837 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_getLabelNames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_getLabelNames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::getLabelNames(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::getLabelNames(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 479 "FnBinding.xs"
		clearErrMsg();
		FnBinding *obj = self->get();

		const RowSetType::NameVec &names = obj->getLabelNames();
		int nf = names.size();
		for (int i = 0; i < nf; i++) {
			XPUSHs(sv_2mortal(newSVpvn(names[i].c_str(), names[i].size())));
		}
#line 874 "FnBinding.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__FnBinding_getDefinedLabelNames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_getDefinedLabelNames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::getDefinedLabelNames(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::getDefinedLabelNames(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 492 "FnBinding.xs"
		clearErrMsg();
		FnBinding *obj = self->get();

		const RowSetType::NameVec &names = obj->getLabelNames();
		int nf = names.size();
		for (int i = 0; i < nf; i++) {
			if (obj->getLabel(i) != NULL)
				XPUSHs(sv_2mortal(newSVpvn(names[i].c_str(), names[i].size())));
		}
#line 912 "FnBinding.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__FnBinding_getLabels); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_getLabels)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::getLabels(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::getLabels(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 507 "FnBinding.xs"
		// for casting of return valus
		static char CLASS[] = "Triceps::Label";
		clearErrMsg();
		FnBinding *obj = self->get();

		const FnBinding::LabelVec &labels = obj->getLabels();
		int nf = labels.size();
		for (int i = 0; i < nf; i++) {
			Label *lb = labels[i];
			if (lb == NULL) {
				XPUSHs(&PL_sv_undef);
			} else {
				SV *sub = newSV(0);
				sv_setref_pv( sub, CLASS, (void*)(new WrapLabel(lb)) );
				XPUSHs(sv_2mortal(sub));
			}
		}
#line 958 "FnBinding.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__FnBinding_getLabelHash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_getLabelHash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::getLabelHash(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::getLabelHash(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 531 "FnBinding.xs"
		// for casting of return valus
		static char CLASS[] = "Triceps::Label";
		clearErrMsg();
		FnBinding *obj = self->get();

		const FnBinding::LabelVec &labels = obj->getLabels();
		int nf = labels.size();
		for (int i = 0; i < nf; i++) {
			const string &name = *obj->getLabelName(i);
			XPUSHs(sv_2mortal(newSVpvn(name.c_str(), name.size())));
			Label *lb = labels[i];
			if (lb == NULL) {
				XPUSHs(&PL_sv_undef);
			} else {
				SV *sub = newSV(0);
				sv_setref_pv( sub, CLASS, (void*)(new WrapLabel(lb)) );
				XPUSHs(sv_2mortal(sub));
			}
		}
#line 1006 "FnBinding.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__FnBinding_getRowTypeHash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_getRowTypeHash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::getRowTypeHash(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::getRowTypeHash(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 556 "FnBinding.xs"
		// for casting of return valus
		static char CLASS[] = "Triceps::RowType";
		clearErrMsg();
		FnBinding *obj = self->get();

		const RowSetType::RowTypeVec &rts = obj->getRowTypes();
		int nf = rts.size();
		for (int i = 0; i < nf; i++) {
			const string &name = *obj->getLabelName(i);
			XPUSHs(sv_2mortal(newSVpvn(name.c_str(), name.size())));
			SV *sub = newSV(0);
			sv_setref_pv( sub, CLASS, (void*)(new WrapRowType(rts[i])) );
			XPUSHs(sv_2mortal(sub));
		}
#line 1049 "FnBinding.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__FnBinding_getLabelMapping); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_getLabelMapping)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	RETVAL;
	WrapFnBinding *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::getLabelMapping(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::getLabelMapping(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 575 "FnBinding.xs"
		clearErrMsg();
		FnBinding *obj = self->get();

		const RowSetType::NameVec &names = obj->getLabelNames();
		int nf = names.size();
		for (int i = 0; i < nf; i++) {
			XPUSHs(sv_2mortal(newSVpvn(names[i].c_str(), names[i].size())));
			XPUSHs(sv_2mortal(newSViv(i)));
		}
#line 1087 "FnBinding.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Triceps__FnBinding_getLabel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_getLabel)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, name");
    {
	WrapLabel *	RETVAL;
	WrapFnBinding *	self;
	char *	name = (char *)SvPV_nolen(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::getLabel(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::getLabel(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 591 "FnBinding.xs"
		// for casting of return valus
		static char CLASS[] = "Triceps::Label";
		clearErrMsg();
		FnBinding *obj = self->get();
		int idx = obj->findLabel(name);
		try {
			if (idx < 0)
				throw Exception::f("Triceps::FnBinding::getLabel: unknown label name '%s'.", name);
		} TRICEPS_CATCH_CROAK;
		Label *lb = obj->getLabel(idx);
		if (lb == NULL)
			XSRETURN_UNDEF; // properly return an undef
		RETVAL = new WrapLabel(lb);
#line 1129 "FnBinding.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_getLabelAt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_getLabelAt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, idx");
    {
	WrapLabel *	RETVAL;
	WrapFnBinding *	self;
	int	idx = (int)SvIV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::getLabelAt(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::getLabelAt(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 613 "FnBinding.xs"
		// for casting of return valus
		static char CLASS[] = "Triceps::Label";
		clearErrMsg();
		FnBinding *obj = self->get();
		try {
			if (idx < 0 || idx >= obj->size())
				throw Exception::f("Triceps::FnBinding::getLabelAt: bad index %d, valid range is 0..%d.", idx, obj->size()-1);
		} TRICEPS_CATCH_CROAK;
		Label *lb = obj->getLabel(idx);
		if (lb == NULL)
			XSRETURN_UNDEF; // properly return an undef
		RETVAL = new WrapLabel(lb);
#line 1171 "FnBinding.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__FnBinding_findLabel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__FnBinding_findLabel)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, name");
    {
	int	RETVAL;
	dXSTARG;
	WrapFnBinding *	self;
	char *	name = (char *)SvPV_nolen(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapFnBinding *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::FnBinding::findLabel(): self has an incorrect magic for WrapFnBindingPtr" );
		}
	} else{
		croakWithMsg( "Triceps::FnBinding::findLabel(): self is not a blessed SV reference to WrapFnBindingPtr" );
	}
;
#line 632 "FnBinding.xs"
		clearErrMsg();
		FnBinding *obj = self->get();
		RETVAL = obj->findLabel(name);
		try {
			if (RETVAL < 0)
				throw Exception::f("Triceps::FnBinding::findLabel: unknown label name '%s'.", name);
		} TRICEPS_CATCH_CROAK;
#line 1209 "FnBinding.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Triceps__FnBinding); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Triceps__FnBinding)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("Triceps::FnBinding::CLONE_SKIP", XS_Triceps__FnBinding_CLONE_SKIP, file);
        newXS("Triceps::FnBinding::DESTROY", XS_Triceps__FnBinding_DESTROY, file);
        newXS("Triceps::FnBinding::same", XS_Triceps__FnBinding_same, file);
        newXS("Triceps::FnBinding::new", XS_Triceps__FnBinding_new, file);
        newXS("Triceps::FnBinding::call", XS_Triceps__FnBinding_call, file);
        newXS("Triceps::FnBinding::getName", XS_Triceps__FnBinding_getName, file);
        newXS("Triceps::FnBinding::withTray", XS_Triceps__FnBinding_withTray, file);
        newXS("Triceps::FnBinding::callTray", XS_Triceps__FnBinding_callTray, file);
        newXS("Triceps::FnBinding::traySize", XS_Triceps__FnBinding_traySize, file);
        newXS("Triceps::FnBinding::trayEmpty", XS_Triceps__FnBinding_trayEmpty, file);
        newXS("Triceps::FnBinding::swapTray", XS_Triceps__FnBinding_swapTray, file);
        newXS("Triceps::FnBinding::equals", XS_Triceps__FnBinding_equals, file);
        newXS("Triceps::FnBinding::match", XS_Triceps__FnBinding_match, file);
        newXS("Triceps::FnBinding::size", XS_Triceps__FnBinding_size, file);
        newXS("Triceps::FnBinding::getLabelNames", XS_Triceps__FnBinding_getLabelNames, file);
        newXS("Triceps::FnBinding::getDefinedLabelNames", XS_Triceps__FnBinding_getDefinedLabelNames, file);
        newXS("Triceps::FnBinding::getLabels", XS_Triceps__FnBinding_getLabels, file);
        newXS("Triceps::FnBinding::getLabelHash", XS_Triceps__FnBinding_getLabelHash, file);
        newXS("Triceps::FnBinding::getRowTypeHash", XS_Triceps__FnBinding_getRowTypeHash, file);
        newXS("Triceps::FnBinding::getLabelMapping", XS_Triceps__FnBinding_getLabelMapping, file);
        newXS("Triceps::FnBinding::getLabel", XS_Triceps__FnBinding_getLabel, file);
        newXS("Triceps::FnBinding::getLabelAt", XS_Triceps__FnBinding_getLabelAt, file);
        newXS("Triceps::FnBinding::findLabel", XS_Triceps__FnBinding_findLabel, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

