/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of Table.xs. Do not edit this file, edit Table.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Table.xs"
//
// (C) Copyright 2011-2014 Sergey A. Babkin.
// This file is a part of Triceps.
// See the file COPYRIGHT for the copyright notice and license information
//
// The wrapper for Table.

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include "TricepsPerl.h"

namespace TRICEPS_NS
{
namespace TricepsPerl 
{

// Parse the argument as either a RowHandle (then return it directly)
// or a Row (then create a RowHandle from it).
// On errors throws an Exception.
// @patab tab - table where the handle will be used
// @param funcName - calling function name, for error messages
// @param arg - the incoming argument
// @return - a RowHandle; put it into Rhref because handle may be just created!!!
RowHandle *parseRowOrHandle(Table *tab, const char *funcName, SV *arg)
{
	if( sv_isobject(arg) && (SvTYPE(SvRV(arg)) == SVt_PVMG) ) {
		WrapRowHandle *wrh = (WrapRowHandle *)SvIV((SV*)SvRV( arg ));
		if (wrh == 0) {
			throw Exception::f("%s: row argument is NULL and not a valid SV reference to Row or RowHandle", funcName);
		}
		if (!wrh->badMagic()) {
			if (wrh->ref_.getTable() != tab) {
				throw Exception::f("%s: row argument is a RowHandle in a wrong table %s",
					funcName, wrh->ref_.getTable()->getName().c_str());
			}
			RowHandle *rh = wrh->get();
			if (rh == NULL) {
				throw Exception::f("%s: RowHandle is NULL", funcName);
			}
			return rh;
		}
		WrapRow *wr = (WrapRow *)wrh;
		if (wr->badMagic()) {
			throw Exception::f("%s: row argument has an incorrect magic for Row or RowHandle", funcName);
		}

		Row *r = wr->get();
		const RowType *rt = wr->ref_.getType();

		if (!rt->match(tab->getRowType())) {
			string msg = strprintf("%s: table and row types are not equal, in table: ", funcName);
			tab->getRowType()->printTo(msg, NOINDENT);
			msg.append(", in row: ");
			rt->printTo(msg, NOINDENT);

			throw Exception(msg, false);
		}
		return tab->makeRowHandle(r);
	} else{
		throw Exception::f("%s: row argument is not a blessed SV reference to Row or RowHandle", funcName);
	}
}

}; // Triceps::TricepsPerl
}; // Triceps

#line 81 "Table.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 223 "Table.c"

XS_EUPXS(XS_Triceps__Table_CLONE_SKIP); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_CLONE_SKIP)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 77 "Table.xs"
		RETVAL = 1;
#line 235 "Table.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::DESTROY(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::DESTROY(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 84 "Table.xs"
		// warn("Table destroyed!");
		delete self;
#line 263 "Table.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__Table_getInputLabel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_getInputLabel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapLabel *	RETVAL;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::getInputLabel(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::getInputLabel(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 93 "Table.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::Label";

		clearErrMsg();
		Table *t = self->get();
		RETVAL = new WrapLabel(t->getInputLabel());
#line 295 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_getOutputLabel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_getOutputLabel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapLabel *	RETVAL;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::getOutputLabel(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::getOutputLabel(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 107 "Table.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::Label";

		clearErrMsg();
		Table *t = self->get();
		RETVAL = new WrapLabel(t->getLabel());
#line 329 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_getPreLabel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_getPreLabel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapLabel *	RETVAL;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::getPreLabel(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::getPreLabel(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 119 "Table.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::Label";

		clearErrMsg();
		Table *t = self->get();
		RETVAL = new WrapLabel(t->getPreLabel());
#line 363 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_getDumpLabel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_getDumpLabel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapLabel *	RETVAL;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::getDumpLabel(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::getDumpLabel(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 131 "Table.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::Label";

		clearErrMsg();
		Table *t = self->get();
		RETVAL = new WrapLabel(t->getDumpLabel());
#line 397 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_getAggregatorLabel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_getAggregatorLabel)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, aggname");
    {
	WrapLabel *	RETVAL;
	WrapTable *	self;
	char *	aggname = (char *)SvPV_nolen(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::getAggregatorLabel(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::getAggregatorLabel(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 143 "Table.xs"
		static char funcName[] =  "Triceps::Table::getAggregatorLabel";
		// for casting of return value
		static char CLASS[] = "Triceps::Label";

		clearErrMsg();
		Table *t = self->get();
		Label *lab = t->getAggregatorLabel(aggname);

		try { do {
			if (lab == NULL)
				throw Exception::f("%s: aggregator '%s' is not defined on table '%s'", funcName, aggname, t->getName().c_str());
		} while(0); } TRICEPS_CATCH_CROAK;
		RETVAL = new WrapLabel(lab);
#line 440 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_getType); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_getType)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapTableType *	RETVAL;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::getType(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::getType(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 162 "Table.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::TableType";

		clearErrMsg();
		Table *t = self->get();
		RETVAL = new WrapTableType(const_cast<TableType *>(t->getType()));
#line 474 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_getUnit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_getUnit)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapUnit *	RETVAL;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::getUnit(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::getUnit(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 174 "Table.xs"
		clearErrMsg();
		Table *tab = self->get();

		// for casting of return value
		static char CLASS[] = "Triceps::Unit";
		RETVAL = new WrapUnit(tab->getUnit());
#line 508 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_same); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_same)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	int	RETVAL;
	dXSTARG;
	WrapTable *	self;
	WrapTable *	other;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::same(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::same(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		other = (WrapTable *)SvIV((SV*)SvRV( ST(1) ));
		if (other == 0 || other->badMagic()) {
			croakWithMsg( "Triceps::Table::same(): other has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::same(): other is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 187 "Table.xs"
		clearErrMsg();
		Table *t = self->get();
		Table *ot = other->get();
		RETVAL = (t == ot);
#line 552 "Table.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_getRowType); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_getRowType)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapRowType *	RETVAL;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::getRowType(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::getRowType(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 197 "Table.xs"
		clearErrMsg();
		Table *tab = self->get();

		// for casting of return value
		static char CLASS[] = "Triceps::RowType";
		RETVAL = new WrapRowType(const_cast<RowType *>(tab->getRowType()));
#line 585 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_getName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_getName)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	char *	RETVAL;
	dXSTARG;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::getName(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::getName(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 209 "Table.xs"
		clearErrMsg();
		Table *t = self->get();
		RETVAL = (char *)t->getName().c_str();
#line 617 "Table.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	IV	RETVAL;
	dXSTARG;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::size(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::size(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 219 "Table.xs"
		clearErrMsg();
		Table *t = self->get();
		RETVAL = t->size();
#line 648 "Table.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_fnReturn); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_fnReturn)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapFnReturn *	RETVAL;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::fnReturn(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::fnReturn(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 228 "Table.xs"
		static char funcName[] =  "Triceps::Table::fnReturn";
		// for casting of return value
		static char CLASS[] = "Triceps::FnReturn";
		RETVAL = NULL; // shut up the warning

		clearErrMsg();
		Table *t = self->get();

		try { do {
			RETVAL = new WrapFnReturn(t->fnReturn());
		} while(0); } TRICEPS_CATCH_CROAK;
#line 686 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_makeRowHandle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_makeRowHandle)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, row");
    {
	WrapRowHandle *	RETVAL;
	WrapTable *	self;
	WrapRow *	row;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::makeRowHandle(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::makeRowHandle(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		row = (WrapRow *)SvIV((SV*)SvRV( ST(1) ));
		if (row == 0 || row->badMagic()) {
			croakWithMsg( "Triceps::Table::makeRowHandle(): row has an incorrect magic for WrapRowPtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::makeRowHandle(): row is not a blessed SV reference to WrapRowPtr" );
	}
;
#line 245 "Table.xs"
		static char funcName[] =  "Triceps::Table::makeRowHandle";
		// for casting of return value
		static char CLASS[] = "Triceps::RowHandle";

		clearErrMsg();
		Table *t = self->get();
		Row *r = row->get();
		const RowType *rt = row->ref_.getType();

		try { do {
			if (!rt->match(t->getRowType())) {
				string msg = strprintf("%s: table and row types are not equal, in table: ", funcName);
				t->getRowType()->printTo(msg, NOINDENT);
				msg.append(", in row: ");
				rt->printTo(msg, NOINDENT);

				throw Exception(msg, false);
			}
		} while(0); } TRICEPS_CATCH_CROAK;

		RETVAL = new WrapRowHandle(t, t->makeRowHandle(r));
#line 746 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_makeNullRowHandle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_makeNullRowHandle)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapRowHandle *	RETVAL;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::makeNullRowHandle(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::makeNullRowHandle(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 273 "Table.xs"
		// for casting of return value
		static char CLASS[] = "Triceps::RowHandle";

		clearErrMsg();
		Table *t = self->get();

		RETVAL = new WrapRowHandle(t, NULL);
#line 781 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_insert); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_insert)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, rowarg");
    {
	int	RETVAL;
	dXSTARG;
	WrapTable *	self;
	SV *	rowarg = ST(1)
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::insert(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::insert(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 288 "Table.xs"
		RETVAL = 0; // shut up the warning
		static char funcName[] =  "Triceps::Table::insert";
		try { do {
			clearErrMsg();
			Table *t = self->get();

			Rhref rhr(t,  parseRowOrHandle(t, funcName, rowarg)); // may throw

			RETVAL = t->insert(rhr.get());
		} while(0); } TRICEPS_CATCH_CROAK;
#line 822 "Table.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_remove); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_remove)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, wrh");
    {
	int	RETVAL;
	dXSTARG;
	WrapTable *	self;
	WrapRowHandle *	wrh;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::remove(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::remove(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		wrh = (WrapRowHandle *)SvIV((SV*)SvRV( ST(1) ));
		if (wrh == 0 || wrh->badMagic()) {
			croakWithMsg( "Triceps::Table::remove(): wrh has an incorrect magic for WrapRowHandlePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::remove(): wrh is not a blessed SV reference to WrapRowHandlePtr" );
	}
;
#line 305 "Table.xs"
		try { do {
			static char funcName[] =  "Triceps::Table::remove";

			clearErrMsg();
			Table *t = self->get();
			RowHandle *rh = wrh->get();

			if (rh == NULL) {
				throw Exception::f("%s: RowHandle is NULL", funcName);
			}

			if (wrh->ref_.getTable() != t) {
				throw Exception::f("%s: row argument is a RowHandle in a wrong table %s",
					funcName, wrh->ref_.getTable()->getName().c_str());
			}

			t->remove(rh);
		} while(0); } TRICEPS_CATCH_CROAK;
		RETVAL = 1;
#line 880 "Table.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_deleteRow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_deleteRow)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, wr");
    {
	int	RETVAL;
	dXSTARG;
	WrapTable *	self;
	WrapRow *	wr;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::deleteRow(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::deleteRow(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		wr = (WrapRow *)SvIV((SV*)SvRV( ST(1) ));
		if (wr == 0 || wr->badMagic()) {
			croakWithMsg( "Triceps::Table::deleteRow(): wr has an incorrect magic for WrapRowPtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::deleteRow(): wr is not a blessed SV reference to WrapRowPtr" );
	}
;
#line 332 "Table.xs"
		RETVAL = 0; // shut up the warning
		try { do {
			static char funcName[] =  "Triceps::Table::deleteRow";

			clearErrMsg();
			Table *t = self->get();
			Row *r = wr->get();
			const RowType *rt = wr->ref_.getType();

			if (!rt->match(t->getRowType())) {
				string msg = strprintf("%s: table and row types are not equal, in table: ", funcName);
				t->getRowType()->printTo(msg, NOINDENT);
				msg.append(", in row: ");
				rt->printTo(msg, NOINDENT);

				throw TRICEPS_NS::Exception(msg, false);
			}

			// pretty much a copy of C++ Table::InputLabel::execute()
			RETVAL = t->deleteRow(r)? 1 : 0;
		} while(0); } TRICEPS_CATCH_CROAK;
#line 940 "Table.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_begin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_begin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	WrapRowHandle *	RETVAL;
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::begin(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::begin(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 361 "Table.xs"
		static char CLASS[] = "Triceps::RowHandle";

		clearErrMsg();
		Table *t = self->get();
		RETVAL = new WrapRowHandle(t, t->begin());
#line 972 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_beginIdx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_beginIdx)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, widx");
    {
	WrapRowHandle *	RETVAL;
	WrapTable *	self;
	WrapIndexType *	widx;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::beginIdx(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::beginIdx(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		widx = (WrapIndexType *)SvIV((SV*)SvRV( ST(1) ));
		if (widx == 0 || widx->badMagic()) {
			croakWithMsg( "Triceps::Table::beginIdx(): widx has an incorrect magic for WrapIndexTypePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::beginIdx(): widx is not a blessed SV reference to WrapIndexTypePtr" );
	}
;
#line 372 "Table.xs"
		static char CLASS[] = "Triceps::RowHandle";

		RETVAL = NULL; // shut up the warning
		try { do {
			clearErrMsg();
			Table *t = self->get();
			IndexType *idx = widx->get();

			static char funcName[] =  "Triceps::Table::beginIdx";
			if (idx->getTabtype() != t->getType()) {
				throw TRICEPS_NS::Exception(strprintf("%s: indexType argument does not belong to table's type", funcName), false);
			}

			RETVAL = new WrapRowHandle(t, t->beginIdx(idx));
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1026 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_next)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, wcur");
    {
	WrapRowHandle *	RETVAL;
	WrapTable *	self;
	WrapRowHandle *	wcur;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::next(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::next(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		wcur = (WrapRowHandle *)SvIV((SV*)SvRV( ST(1) ));
		if (wcur == 0 || wcur->badMagic()) {
			croakWithMsg( "Triceps::Table::next(): wcur has an incorrect magic for WrapRowHandlePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::next(): wcur is not a blessed SV reference to WrapRowHandlePtr" );
	}
;
#line 393 "Table.xs"
		static char CLASS[] = "Triceps::RowHandle";

		RETVAL = NULL; // shut up the warning
		try { do {
			clearErrMsg();
			Table *t = self->get();
			RowHandle *cur = wcur->get(); // NULL is OK

			static char funcName[] =  "Triceps::Table::next";
			if (wcur->ref_.getTable() != t) {
				throw TRICEPS_NS::Exception(strprintf("%s: row argument is a RowHandle in a wrong table %s",
					funcName, wcur->ref_.getTable()->getName().c_str()), false);
			}

			RETVAL = new WrapRowHandle(t, t->next(cur));
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1081 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_nextIdx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_nextIdx)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, widx, wcur");
    {
	WrapRowHandle *	RETVAL;
	WrapTable *	self;
	WrapIndexType *	widx;
	WrapRowHandle *	wcur;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::nextIdx(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::nextIdx(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		widx = (WrapIndexType *)SvIV((SV*)SvRV( ST(1) ));
		if (widx == 0 || widx->badMagic()) {
			croakWithMsg( "Triceps::Table::nextIdx(): widx has an incorrect magic for WrapIndexTypePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::nextIdx(): widx is not a blessed SV reference to WrapIndexTypePtr" );
	}
;

	if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
		wcur = (WrapRowHandle *)SvIV((SV*)SvRV( ST(2) ));
		if (wcur == 0 || wcur->badMagic()) {
			croakWithMsg( "Triceps::Table::nextIdx(): wcur has an incorrect magic for WrapRowHandlePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::nextIdx(): wcur is not a blessed SV reference to WrapRowHandlePtr" );
	}
;
#line 415 "Table.xs"
		static char CLASS[] = "Triceps::RowHandle";

		RETVAL = NULL; // shut up the warning
		try { do {
			clearErrMsg();
			Table *t = self->get();
			IndexType *idx = widx->get();
			RowHandle *cur = wcur->get(); // NULL is OK

			static char funcName[] =  "Triceps::Table::nextIdx";
			if (idx->getTabtype() != t->getType()) {
				throw TRICEPS_NS::Exception(strprintf("%s: indexType argument does not belong to table's type", funcName), false);
			}
			if (wcur->ref_.getTable() != t) {
				throw TRICEPS_NS::Exception(strprintf("%s: row argument is a RowHandle in a wrong table %s",
					funcName, wcur->ref_.getTable()->getName().c_str()), false);
			}

			RETVAL = new WrapRowHandle(t, t->nextIdx(idx, cur));
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1151 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_firstOfGroupIdx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_firstOfGroupIdx)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, widx, wcur");
    {
	WrapRowHandle *	RETVAL;
	WrapTable *	self;
	WrapIndexType *	widx;
	WrapRowHandle *	wcur;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::firstOfGroupIdx(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::firstOfGroupIdx(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		widx = (WrapIndexType *)SvIV((SV*)SvRV( ST(1) ));
		if (widx == 0 || widx->badMagic()) {
			croakWithMsg( "Triceps::Table::firstOfGroupIdx(): widx has an incorrect magic for WrapIndexTypePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::firstOfGroupIdx(): widx is not a blessed SV reference to WrapIndexTypePtr" );
	}
;

	if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
		wcur = (WrapRowHandle *)SvIV((SV*)SvRV( ST(2) ));
		if (wcur == 0 || wcur->badMagic()) {
			croakWithMsg( "Triceps::Table::firstOfGroupIdx(): wcur has an incorrect magic for WrapRowHandlePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::firstOfGroupIdx(): wcur is not a blessed SV reference to WrapRowHandlePtr" );
	}
;
#line 441 "Table.xs"
		static char CLASS[] = "Triceps::RowHandle";

		RETVAL = NULL; // shut up the warning
		try { do {
			clearErrMsg();
			Table *t = self->get();
			IndexType *idx = widx->get();
			RowHandle *cur = wcur->get(); // NULL is OK

			static char funcName[] =  "Triceps::Table::firstOfGroupIdx";
			if (idx->getTabtype() != t->getType()) {
				throw TRICEPS_NS::Exception(strprintf("%s: indexType argument does not belong to table's type", funcName), false);
			}
			if (wcur->ref_.getTable() != t) {
				throw TRICEPS_NS::Exception(strprintf("%s: row argument is a RowHandle in a wrong table %s",
					funcName, wcur->ref_.getTable()->getName().c_str()), false);
			}

			RETVAL = new WrapRowHandle(t, t->firstOfGroupIdx(idx, cur));
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1221 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_nextGroupIdx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_nextGroupIdx)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, widx, wcur");
    {
	WrapRowHandle *	RETVAL;
	WrapTable *	self;
	WrapIndexType *	widx;
	WrapRowHandle *	wcur;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::nextGroupIdx(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::nextGroupIdx(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		widx = (WrapIndexType *)SvIV((SV*)SvRV( ST(1) ));
		if (widx == 0 || widx->badMagic()) {
			croakWithMsg( "Triceps::Table::nextGroupIdx(): widx has an incorrect magic for WrapIndexTypePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::nextGroupIdx(): widx is not a blessed SV reference to WrapIndexTypePtr" );
	}
;

	if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
		wcur = (WrapRowHandle *)SvIV((SV*)SvRV( ST(2) ));
		if (wcur == 0 || wcur->badMagic()) {
			croakWithMsg( "Triceps::Table::nextGroupIdx(): wcur has an incorrect magic for WrapRowHandlePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::nextGroupIdx(): wcur is not a blessed SV reference to WrapRowHandlePtr" );
	}
;
#line 467 "Table.xs"
		static char CLASS[] = "Triceps::RowHandle";

		RETVAL = NULL; // shut up the warning
		try { do {
			clearErrMsg();
			Table *t = self->get();
			IndexType *idx = widx->get();
			RowHandle *cur = wcur->get(); // NULL is OK

			static char funcName[] =  "Triceps::Table::nextGroupIdx";
			if (idx->getTabtype() != t->getType()) {
				throw TRICEPS_NS::Exception(strprintf("%s: indexType argument does not belong to table's type", funcName), false);
			}
			if (wcur->ref_.getTable() != t) {
				throw TRICEPS_NS::Exception(strprintf("%s: row argument is a RowHandle in a wrong table %s",
					funcName, wcur->ref_.getTable()->getName().c_str()), false);
			}

			RETVAL = new WrapRowHandle(t, t->nextGroupIdx(idx, cur));
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1291 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_find); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_find)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, rowarg");
    {
	WrapRowHandle *	RETVAL;
	WrapTable *	self;
	SV *	rowarg = ST(1)
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::find(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::find(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 493 "Table.xs"
		static char CLASS[] = "Triceps::RowHandle";
		static char funcName[] =  "Triceps::Table::find";

		RETVAL = NULL; // shut up the warning
		try { do {
			clearErrMsg();
			Table *t = self->get();

			Rhref rhr(t,  parseRowOrHandle(t, funcName, rowarg)); // may throw

			RETVAL = new WrapRowHandle(t, t->find(rhr.get()));
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1333 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_findIdx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_findIdx)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, widx, rowarg");
    {
	WrapRowHandle *	RETVAL;
	WrapTable *	self;
	WrapIndexType *	widx;
	SV *	rowarg = ST(2)
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::findIdx(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::findIdx(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		widx = (WrapIndexType *)SvIV((SV*)SvRV( ST(1) ));
		if (widx == 0 || widx->badMagic()) {
			croakWithMsg( "Triceps::Table::findIdx(): widx has an incorrect magic for WrapIndexTypePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::findIdx(): widx is not a blessed SV reference to WrapIndexTypePtr" );
	}
;
#line 511 "Table.xs"
		static char CLASS[] = "Triceps::RowHandle";
		static char funcName[] =  "Triceps::Table::findIdx";

		RETVAL = NULL; // shut up the warning
		try { do {
			clearErrMsg();
			Table *t = self->get();
			IndexType *idx = widx->get();

			if (idx->getTabtype() != t->getType()) {
				throw TRICEPS_NS::Exception(strprintf("%s: indexType argument does not belong to table's type", funcName), false);
			}

			Rhref rhr(t,  parseRowOrHandle(t, funcName, rowarg)); // may throw

			RETVAL = new WrapRowHandle(t, t->findIdx(idx, rhr.get()));
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1391 "Table.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_groupSizeIdx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_groupSizeIdx)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, widx, rowarg");
    {
	int	RETVAL;
	dXSTARG;
	WrapTable *	self;
	WrapIndexType *	widx;
	SV *	rowarg = ST(2)
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::groupSizeIdx(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::groupSizeIdx(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		widx = (WrapIndexType *)SvIV((SV*)SvRV( ST(1) ));
		if (widx == 0 || widx->badMagic()) {
			croakWithMsg( "Triceps::Table::groupSizeIdx(): widx has an incorrect magic for WrapIndexTypePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::groupSizeIdx(): widx is not a blessed SV reference to WrapIndexTypePtr" );
	}
;
#line 534 "Table.xs"
		static char CLASS[] = "Triceps::RowHandle";
		static char funcName[] =  "Triceps::Table::groupSizeIdx";

		RETVAL = NULL; // shut up the warning
		try { do {
			clearErrMsg();
			Table *t = self->get();
			IndexType *idx = widx->get();

			if (idx->getTabtype() != t->getType()) {
				throw TRICEPS_NS::Exception(strprintf("%s: indexType argument does not belong to table's type", funcName), false);
			}

			Rhref rhr(t,  parseRowOrHandle(t, funcName, rowarg)); // may throw

			RETVAL = t->groupSizeIdx(idx, rhr.get());
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1450 "Table.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Triceps__Table_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_clear)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::clear(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::clear(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 560 "Table.xs"
		static char funcName[] =  "Triceps::Table::clear";

		try { do {
			clearErrMsg();
			Table *t = self->get();
			size_t arg;

			if (items == 1) {
				arg = 0;
			} else if (items == 2) {
				IV iarg = SvIV(ST(1));
				if (iarg < 0)
					throw TRICEPS_NS::Exception::f("%s: the limit argument must be >=0, got %lld", 
						funcName, (long long)iarg);
				arg = (size_t)iarg;
			} else {
				throw TRICEPS_NS::Exception::f("Usage: %s(self [, limit])", funcName);
			}

			t->clear(arg);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1497 "Table.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__Table_dumpAll); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_dumpAll)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	WrapTable *	self;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::dumpAll(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::dumpAll(): self is not a blessed SV reference to WrapTablePtr" );
	}
;
#line 585 "Table.xs"
		try { do {
			static char funcName[] =  "Triceps::Table::dumpAll";
			clearErrMsg();
			Table *t = self->get();
			Rowop::Opcode op;

			if (items == 1) {
				op = Rowop::OP_INSERT;
			} else if (items == 2) {
				op = parseOpcode(funcName, ST(1)); // may throw
			} else {
				throw TRICEPS_NS::Exception::f("Usage: %s(self [, opcode])", funcName);
			}

			t->dumpAll(op);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1538 "Table.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Triceps__Table_dumpAllIdx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Triceps__Table_dumpAllIdx)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "self, widx, ...");
    {
	WrapTable *	self;
	WrapIndexType *	widx;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
		self = (WrapTable *)SvIV((SV*)SvRV( ST(0) ));
		if (self == 0 || self->badMagic()) {
			croakWithMsg( "Triceps::Table::dumpAllIdx(): self has an incorrect magic for WrapTablePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::dumpAllIdx(): self is not a blessed SV reference to WrapTablePtr" );
	}
;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
		widx = (WrapIndexType *)SvIV((SV*)SvRV( ST(1) ));
		if (widx == 0 || widx->badMagic()) {
			croakWithMsg( "Triceps::Table::dumpAllIdx(): widx has an incorrect magic for WrapIndexTypePtr" );
		}
	} else{
		croakWithMsg( "Triceps::Table::dumpAllIdx(): widx is not a blessed SV reference to WrapIndexTypePtr" );
	}
;
#line 605 "Table.xs"
		try { do {
			static char funcName[] =  "Triceps::Table::dumpAllIdx";
			clearErrMsg();
			Table *t = self->get();
			IndexType *idx = widx->get();
			Rowop::Opcode op;

			if (idx->getTabtype() != t->getType()) {
				throw TRICEPS_NS::Exception(strprintf("%s: indexType argument does not belong to table's type", funcName), false);
			}

			if (items <= 2) {
				op = Rowop::OP_INSERT;
			} else if (items == 3) {
				op = parseOpcode(funcName, ST(2)); // may throw
			} else {
				throw TRICEPS_NS::Exception::f("Usage: %s(self, widx [, opcode])", funcName);
			}

			t->dumpAllIdx(idx, op);
		} while(0); } TRICEPS_CATCH_CROAK;
#line 1595 "Table.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Triceps__Table); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Triceps__Table)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("Triceps::Table::CLONE_SKIP", XS_Triceps__Table_CLONE_SKIP, file);
        newXS("Triceps::Table::DESTROY", XS_Triceps__Table_DESTROY, file);
        newXS("Triceps::Table::getInputLabel", XS_Triceps__Table_getInputLabel, file);
        newXS("Triceps::Table::getOutputLabel", XS_Triceps__Table_getOutputLabel, file);
        newXS("Triceps::Table::getPreLabel", XS_Triceps__Table_getPreLabel, file);
        newXS("Triceps::Table::getDumpLabel", XS_Triceps__Table_getDumpLabel, file);
        newXS("Triceps::Table::getAggregatorLabel", XS_Triceps__Table_getAggregatorLabel, file);
        newXS("Triceps::Table::getType", XS_Triceps__Table_getType, file);
        newXS("Triceps::Table::getUnit", XS_Triceps__Table_getUnit, file);
        newXS("Triceps::Table::same", XS_Triceps__Table_same, file);
        newXS("Triceps::Table::getRowType", XS_Triceps__Table_getRowType, file);
        newXS("Triceps::Table::getName", XS_Triceps__Table_getName, file);
        newXS("Triceps::Table::size", XS_Triceps__Table_size, file);
        newXS("Triceps::Table::fnReturn", XS_Triceps__Table_fnReturn, file);
        newXS("Triceps::Table::makeRowHandle", XS_Triceps__Table_makeRowHandle, file);
        newXS("Triceps::Table::makeNullRowHandle", XS_Triceps__Table_makeNullRowHandle, file);
        newXS("Triceps::Table::insert", XS_Triceps__Table_insert, file);
        newXS("Triceps::Table::remove", XS_Triceps__Table_remove, file);
        newXS("Triceps::Table::deleteRow", XS_Triceps__Table_deleteRow, file);
        newXS("Triceps::Table::begin", XS_Triceps__Table_begin, file);
        newXS("Triceps::Table::beginIdx", XS_Triceps__Table_beginIdx, file);
        newXS("Triceps::Table::next", XS_Triceps__Table_next, file);
        newXS("Triceps::Table::nextIdx", XS_Triceps__Table_nextIdx, file);
        newXS("Triceps::Table::firstOfGroupIdx", XS_Triceps__Table_firstOfGroupIdx, file);
        newXS("Triceps::Table::nextGroupIdx", XS_Triceps__Table_nextGroupIdx, file);
        newXS("Triceps::Table::find", XS_Triceps__Table_find, file);
        newXS("Triceps::Table::findIdx", XS_Triceps__Table_findIdx, file);
        newXS("Triceps::Table::groupSizeIdx", XS_Triceps__Table_groupSizeIdx, file);
        newXS("Triceps::Table::clear", XS_Triceps__Table_clear, file);
        newXS("Triceps::Table::dumpAll", XS_Triceps__Table_dumpAll, file);
        newXS("Triceps::Table::dumpAllIdx", XS_Triceps__Table_dumpAllIdx, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

